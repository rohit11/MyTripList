name: Develop Update Feature Flags Documentation

on:
  schedule:
    - cron: '0 14 * * *'  # 6:00 AM PST
    - cron: '0 2 * * *'   # 6:00 PM PST
  push:
    paths:
      - 'FeatureFlags.tsx'  # Trigger workflow only if FeatureFlags.tsx is modified
  workflow_dispatch:  # Allow manual triggering of the workflow

env:
  FEATURE_FLAGS_DOC: "FEATURE_FLAGS.md"
  FEATURE_FLAG_FILE: "FeatureFlags.tsx"

jobs:
  update-doc:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all branches to ensure release branches are available

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: List All Branches and Get Latest Release Branches
        id: get-latest-release
        run: |
          echo "Listing all remote branches:"
          git branch -r
          
          # Find the two most recent release branches
          release_branches=($(git branch -r --sort=-committerdate | grep 'origin/release/' | head -n 2 | sed 's|origin/||'))
          latest_release=${release_branches[0]}
          previous_release=${release_branches[1]}
          
          if [ -z "$latest_release" ]; then
            echo "No release branch found matching 'release/*'"
            echo "latest_branch=" >> $GITHUB_OUTPUT
          else
            echo "Latest release branch found: $latest_release"
            echo "latest_branch=$latest_release" >> $GITHUB_OUTPUT
          fi

          if [ -z "$previous_release" ]; then
            echo "No previous release branch found."
            echo "previous_branch=" >> $GITHUB_OUTPUT
          else
            echo "Previous release branch found: $previous_release"
            echo "previous_branch=$previous_release" >> $GITHUB_OUTPUT
          fi

      - name: Extract Feature Flags from Latest Release Branch (if available)
        id: extract-latest-release-flags
        run: |
          if [ -n "${{ steps.get-latest-release.outputs.latest_branch }}" ]; then
            git checkout ${{ steps.get-latest-release.outputs.latest_branch }}
            node -e "
              const fs = require('fs');
              const path = require('path');
              const featureFlagFilePath = path.resolve(__dirname, process.env.FEATURE_FLAG_FILE || 'FeatureFlags.tsx');
              const content = fs.readFileSync(featureFlagFilePath, 'utf8');
              const match = content.match(/export const FeatureFlagMapping =\\s*{([\\s\\S]+?)}/);
              if (!match || !match[1]) {
                console.error('FeatureFlagMapping object not found in FeatureFlags.tsx');
                process.exit(1);
              }
              const objectContent = '{' + match[1].trim() + '}';
              const FeatureFlagMapping = eval('(' + objectContent + ')');
              for (const [key, value] of Object.entries(FeatureFlagMapping)) {
                console.log(\`\${key}=\${value}\`);
              }
            " > latest_release_flags.txt
          else
            echo "No latest release branch available. Skipping flag extraction."
            touch latest_release_flags.txt
          fi
          echo "Latest release flags extracted:"
          cat latest_release_flags.txt || echo "No flags extracted from latest release branch"

      - name: Extract Feature Flags from Previous Release Branch (if available)
        id: extract-previous-release-flags
        run: |
          if [ -n "${{ steps.get-latest-release.outputs.previous_branch }}" ]; then
            git checkout ${{ steps.get-latest-release.outputs.previous_branch }}
            node -e "
              const fs = require('fs');
              const path = require('path');
              const featureFlagFilePath = path.resolve(__dirname, process.env.FEATURE_FLAG_FILE || 'FeatureFlags.tsx');
              const content = fs.readFileSync(featureFlagFilePath, 'utf8');
              const match = content.match(/export const FeatureFlagMapping =\\s*{([\\s\\S]+?)}/);
              if (!match || !match[1]) {
                console.error('FeatureFlagMapping object not found in FeatureFlags.tsx');
                process.exit(1);
              }
              const objectContent = '{' + match[1].trim() + '}';
              const FeatureFlagMapping = eval('(' + objectContent + ')');
              for (const [key, value] of Object.entries(FeatureFlagMapping)) {
                console.log(\`\${key}=\${value}\`);
              }
            " > previous_release_flags.txt
          else
            echo "No previous release branch available. Skipping flag extraction."
            touch previous_release_flags.txt
          fi
          echo "Previous release flags extracted:"
          cat previous_release_flags.txt || echo "No flags extracted from previous release branch"

      - name: Extract Feature Flags from Main Branch
        id: extract-main-flags
        run: |
          git checkout main
          node -e "
            const fs = require('fs');
            const path = require('path');
            const featureFlagFilePath = path.resolve(__dirname, process.env.FEATURE_FLAG_FILE || 'FeatureFlags.tsx');
            const content = fs.readFileSync(featureFlagFilePath, 'utf8');
            const match = content.match(/export const FeatureFlagMapping =\\s*{([\\s\\S]+?)}/);
            if (!match || !match[1]) {
              console.error('FeatureFlagMapping object not found in FeatureFlags.tsx');
              process.exit(1);
            }
            const objectContent = '{' + match[1].trim() + '}';
            const FeatureFlagMapping = eval('(' + objectContent + ')');
            for (const [key, value] of Object.entries(FeatureFlagMapping)) {
              console.log(\`\${key}=\${value}\`);
            }
          " > main_flags.txt
          echo "Main branch flags extracted:"
          cat main_flags.txt || echo "No flags extracted from main branch"

      - name: Generate Comparison Markdown
        run: |
          # Initialize associative arrays for release, previous release, and main flags
          declare -A latest_release_flags previous_release_flags main_flags

          # Populate arrays with extracted flags
          while IFS='=' read -r key value; do
            latest_release_flags["$key"]="$value"
          done < latest_release_flags.txt

          while IFS='=' read -r key value; do
            previous_release_flags["$key"]="$value"
          done < previous_release_flags.txt

          while IFS='=' read -r key value; do
            main_flags["$key"]="$value"
          done < main_flags.txt

          # Begin Markdown content
          echo "# Feature Flags Documentation" > ${{ env.FEATURE_FLAGS_DOC }}
          echo "" >> ${{ env.FEATURE_FLAGS_DOC }}

          latest_branch="${{ steps.get-latest-release.outputs.latest_branch }}"
          previous_branch="${{ steps.get-latest-release.outputs.previous_branch }}"

          # Function to print and compare feature flags between latest and previous release
            compare_latest_to_previous_release() {
              local -n latest_flags=$1
              local -n previous_flags=$2
              local latest_branch=$3
              local previous_branch=$4

              echo "## Feature Flags in \`$latest_branch\`" >> ${{ env.FEATURE_FLAGS_DOC }}

              # Begin by printing all feature flags in the latest release
              echo "| Count | Key              | $latest_branch Value       |" >> ${{ env.FEATURE_FLAGS_DOC }}
              echo "|-------|------------------|---------------------------|" >> ${{ env.FEATURE_FLAGS_DOC }}

              count=1
              for key in "${!latest_flags[@]}"; do
                echo "| $count | $key | \`${latest_flags[$key]}\` |" >> ${{ env.FEATURE_FLAGS_DOC }}
                ((count++))
              done
              echo "" >> ${{ env.FEATURE_FLAGS_DOC }}

              # If previous release branch is available, proceed with comparison
              if [ -n "$previous_branch" ]; then
                echo "## Comparison between \`$previous_branch\` and \`$latest_branch\`" >> ${{ env.FEATURE_FLAGS_DOC }}

                new_changes=()
                updated_changes=()
                deleted_changes=()

                # Identify new, updated, and deleted flags
                for key in "${!latest_flags[@]}"; do
                  latest_value="${latest_flags[$key]}"
                  previous_value="${previous_flags[$key]:-N/A}"

                  if [[ "$previous_value" == "N/A" ]]; then
                    new_changes+=("| $count | $key | \`$latest_value\` | New ðŸ”µ |")
                  elif [[ "$latest_value" != "$previous_value" ]]; then
                    updated_changes+=("| $count | $key | \`$latest_value\` | Updated ðŸŸ¡ |")
                  fi
                  ((count++))
                done

                # Identify deleted flags
                for key in "${!previous_flags[@]}"; do
                  if [[ -z "${latest_flags[$key]}" ]]; then
                    deleted_changes+=("| $count | $key | N/A | Deleted ðŸ”´ |")
                    ((count++))
                  fi
                done

                # Output New, Updated, and Deleted tables
                if [ ${#new_changes[@]} -gt 0 ]; then
                  echo "### New Flags" >> ${{ env.FEATURE_FLAGS_DOC }}
                  echo "| Count | Key              | $latest_branch Value       | Status |" >> ${{ env.FEATURE_FLAGS_DOC }}
                  echo "|-------|------------------|---------------------------|--------|" >> ${{ env.FEATURE_FLAGS_DOC }}
                  printf "%s\n" "${new_changes[@]}" >> ${{ env.FEATURE_FLAGS_DOC }}
                  echo "" >> ${{ env.FEATURE_FLAGS_DOC }}
                fi

                if [ ${#updated_changes[@]} -gt 0 ]; then
                  echo "### Updated Flags" >> ${{ env.FEATURE_FLAGS_DOC }}
                  echo "| Count | Key              | $latest_branch Value       | Status |" >> ${{ env.FEATURE_FLAGS_DOC }}
                  echo "|-------|------------------|---------------------------|--------|" >> ${{ env.FEATURE_FLAGS_DOC }}
                  printf "%s\n" "${updated_changes[@]}" >> ${{ env.FEATURE_FLAGS_DOC }}
                  echo "" >> ${{ env.FEATURE_FLAGS_DOC }}
                fi

                if [ ${#deleted_changes[@]} -gt 0 ]; then
                  echo "### Deleted Flags" >> ${{ env.FEATURE_FLAGS_DOC }}
                  echo "| Count | Key              | $latest_branch Value       | Status |" >> ${{ env.FEATURE_FLAGS_DOC }}
                  echo "|-------|------------------|---------------------------|--------|" >> ${{ env.FEATURE_FLAGS_DOC }}
                  printf "%s\n" "${deleted_changes[@]}" >> ${{ env.FEATURE_FLAGS_DOC }}
                  echo "" >> ${{ env.FEATURE_FLAGS_DOC }}
                fi

                # Full Comparison Table
                echo "### Full Feature Flags Comparison" >> ${{ env.FEATURE_FLAGS_DOC }}
                echo "| Count | Key              | $latest_branch Value       | Status |" >> ${{ env.FEATURE_FLAGS_DOC }}
                echo "|-------|------------------|---------------------------|--------|" >> ${{ env.FEATURE_FLAGS_DOC }}

                # Track processed keys for ordering
                declare -A seen_keys
                count=1

                # Output new, updated, and deleted flags first in the full comparison table
                for change in "${new_changes[@]}" "${updated_changes[@]}" "${deleted_changes[@]}"; do
                  echo "$change" >> ${{ env.FEATURE_FLAGS_DOC }}
                done

                # Append unchanged flags at the end of the full comparison table
                for key in "${!latest_flags[@]}"; do
                  if [[ -z "${seen_keys[$key]}" ]] && [[ "${previous_flags[$key]:-N/A}" == "${latest_flags[$key]}" ]]; then
                    echo "| $count | $key | \`${latest_flags[$key]}\` | Unchanged âšª |" >> ${{ env.FEATURE_FLAGS_DOC }}
                    ((count++))
                  fi
                done
              fi
            }

          # Function to perform flag comparison
          compare_flags() {
            local -n source_flags=$1
            local -n target_flags=$2
            local source_name=$3
            local target_name=$4

            echo "## Comparison between \`$source_name\` and \`$target_name\`" >> ${{ env.FEATURE_FLAGS_DOC }}

            new_changes=()
            updated_changes=()
            deleted_changes=()

            # Identify new, updated, and deleted flags based on branch logic
            for key in "${!target_flags[@]}"; do
              source_value="${source_flags[$key]:-N/A}"
              target_value="${target_flags[$key]}"

              if [[ "$source_value" == "N/A" ]]; then
                new_changes+=("| $key | N/A | \`$target_value\` | **New ðŸ”µ** |")
              elif [[ "$source_value" != "$target_value" ]]; then
                updated_changes+=("| $key | \`$source_value\` | \`$target_value\` | **Updated ðŸŸ¡** |")
              fi
            done

            for key in "${!source_flags[@]}"; do
              if [[ -z "${target_flags[$key]}" ]]; then
                deleted_changes+=("| $key | \`${source_flags[$key]}\` | N/A | **Deleted ðŸ”´** |")
              fi
            done

            # Output tables for new, updated, and deleted flags
            if [ ${#new_changes[@]} -gt 0 ]; then
              echo "### New Flags" >> ${{ env.FEATURE_FLAGS_DOC }}
              echo "| Key | $source_name Value | $target_name Value | Status |" >> ${{ env.FEATURE_FLAGS_DOC }}
              echo "|-----|--------------------|--------------------|--------|" >> ${{ env.FEATURE_FLAGS_DOC }}
              printf "%s\n" "${new_changes[@]}" >> ${{ env.FEATURE_FLAGS_DOC }}
              echo "" >> ${{ env.FEATURE_FLAGS_DOC }}
            fi

            if [ ${#updated_changes[@]} -gt 0 ]; then
              echo "### Updated Flags" >> ${{ env.FEATURE_FLAGS_DOC }}
              echo "| Key | $source_name Value | $target_name Value | Status |" >> ${{ env.FEATURE_FLAGS_DOC }}
              echo "|-----|--------------------|--------------------|--------|" >> ${{ env.FEATURE_FLAGS_DOC }}
              printf "%s\n" "${updated_changes[@]}" >> ${{ env.FEATURE_FLAGS_DOC }}
              echo "" >> ${{ env.FEATURE_FLAGS_DOC }}
            fi

            if [ ${#deleted_changes[@]} -gt 0 ]; then
              echo "### Deleted Flags" >> ${{ env.FEATURE_FLAGS_DOC }}
              echo "| Key | $source_name Value | $target_name Value | Status |" >> ${{ env.FEATURE_FLAGS_DOC }}
              echo "|-----|--------------------|--------------------|--------|" >> ${{ env.FEATURE_FLAGS_DOC }}
              printf "%s\n" "${deleted_changes[@]}" >> ${{ env.FEATURE_FLAGS_DOC }}
              echo "" >> ${{ env.FEATURE_FLAGS_DOC }}
            fi

            # Full Comparison Table
            echo "### Full Feature Flags Comparison" >> ${{ env.FEATURE_FLAGS_DOC }}
            echo "| Count | Key | $source_name Value | $target_name Value | Status |" >> ${{ env.FEATURE_FLAGS_DOC }}
            echo "|-------|-----|--------------------|--------------------|--------|" >> ${{ env.FEATURE_FLAGS_DOC }}

            declare -A seen_keys
            count=1

            for key in "${!source_flags[@]}"; do
              source_value="${source_flags[$key]}"
              target_value="${target_flags[$key]:-N/A}"
              status=""

              if [[ "$target_value" == "N/A" ]]; then
                status="Deleted ðŸ”´"
              elif [[ "$source_value" != "$target_value" ]]; then
                status="Updated ðŸŸ¡"
              else
                status="Unchanged âšª"
              fi

              echo "| $count | $key | \`$source_value\` | \`$target_value\` | **$status** |" >> ${{ env.FEATURE_FLAGS_DOC }}
              seen_keys["$key"]=1
              ((count++))
            done

            for key in "${!target_flags[@]}"; do
              if [[ -z "${seen_keys[$key]}" ]]; then
                source_value="N/A"
                target_value="${target_flags[$key]}"
                status="New ðŸ”µ"

                echo "| $count | $key | \`$source_value\` | \`$target_value\` | **$status** |" >> ${{ env.FEATURE_FLAGS_DOC }}
                ((count++))
              fi
            done
          }

          # Call the function with latest and previous release flags
          if [ -n "$latest_branch" ] && [ -n "$previous_branch" ]; then
            compare_latest_to_previous_release latest_release_flags previous_release_flags "$latest_branch" "$previous_branch"
          else
            echo "No previous release available for comparison."
            if [ -n "$latest_branch" ]; then
             compare_latest_to_previous_release latest_release_flags previous_release_flags "$latest_branch" "$previous_branch"
            fi
          fi

          # Compare latest release with previous release if both are available
          #if [ -n "$latest_branch" ] && [ -n "$previous_branch" ]; then
            #compare_flags latest_release_flags previous_release_flags "$latest_branch" "$previous_branch"
          #fi

          # Compare latest release with main
          if [ -n "$latest_branch" ]; then
            compare_flags latest_release_flags main_flags "$latest_branch" "main"
          else 
            echo "No Latest release available for comparison."
            compare_flags latest_release_flags main_flags "$latest_branch" "main"
          fi
          

          echo "Generated FEATURE_FLAGS.md content:"
          cat ${{ env.FEATURE_FLAGS_DOC }}

      - name: Cleanup Temporary Files
        run: |
          rm -f main_flags.txt latest_release_flags.txt previous_release_flags.txt

      - name: Commit and Push Changes
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git add ${{ env.FEATURE_FLAGS_DOC }}
          git commit -m "Update feature flags documentation with comparison" || echo "Nothing to commit"
          git push || echo "Nothing to push"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
